---
layout: post
title: "内核的互斥访问"
description: "关于宏内核与微内核在内核态下的互斥访问方式的区别"
category: os
tags: [os]
---
{% include JB/setup %}

#### 宏内核

宏内核指当系统调用请求来临时，由一个执行流来完成满足系统调用的需求，相对于实验中的采用发送消息的方式实现．但是有些系统调用涉及到慢速的I/O,为提高并发度，我们希望此时能够将中断打开，响应其他中断．

既然要打开中断，那么共享资源的使用就要受到保护，怎么保护？很简单，进入临界区时关中断，离开时开中断．

#### 宏内核的互斥访问

在单核CPU的计算机上，需要进行互斥访问控制的本质原因在于中断的存在．多个线程之间互斥访问控制可以通过信号量提供的互斥锁实现．但是，有一段特殊的代码不能使用信号量实现的互斥锁来同步，那就是处于中断上下文的代码．

- 我们不能使用由信号量实现的互斥锁来解决中断嵌套问题, 你知道为什么吗?

> 信号量实现的互斥锁有一个特征：对当前线程再次引发一次中断．
> 在同步中断上下文的代码时候，有一些数据结构是所有线程都会访问到的．如实验中用到的current指针，以及调度队列等．
> 对这些数据进行访问时候必须进行同步控制，如果使用信号量实现的互斥锁，那么他会再引发一次中断，本意是想要将自己cpu让出，调度其他线程．但是调度其他线程时候要访问共享数据，此时又要同步控制，给自己上锁，又引发一次中断...如此循环反复，甚至连时钟中断来临时候也得循环下去．
> 因此，一种解决方法是采用基于原子指令的锁机制，它要求对共享数据的互斥访问能够通过一个原子指令来实现．

- 在SMP环境下, 如果仅仅使用基于原子指令的锁机制, 还是不能解决中断嵌套问题, 你知道为什么吗? 应该如何正确地解决它?

> 因为原子指令只是针对一个处理器而言的．在多核的处理器环境中，有些共享数据需要保持上下文语义，在一个原子指令内无法实现．解决方法使用关闭内存总线的方式（自己YY的）．

#### 微内核

微内核指代这种系统调用处理方式：当系统调用到来时候，中断上下文代码向相应服务线程发送消息，消息包含了处理系统调用所需要的必要的信息．将主要的处理逻辑分配给相应的处理线程．

由于处理逻辑在其他的线程上下文中，因此这个中断处理过程占用的时间不多，完全可以在关中断的方式下实现互斥访问．因此，在微内核的情况下，使用简单的关中断就能实现互斥访问．

- 我们已经实现了消息机制了, 仔细思考实现的过程, 天然同步的特性究竟从何而来?

> 消息机制通过将数据进行复制来实现通信，本质上它并不会出现多个线程同时处理同一内存区域的情况．当然在消息复制的时候还是要实现互斥的，这就可以通过关中断来实现.

