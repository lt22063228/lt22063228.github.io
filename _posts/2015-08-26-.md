---
layout: post
title: "用户进程"
description: "用户进程是如何从无到有的"
category: os
tags: [os]
---
{% include JB/setup %}

#### 进程的创建

创建一个进程，涉及到初始化PCB（进程控制块），加载程序，创建地址空间等．

- 初始化PCB  
 关键部分包括eip, cs, eflags，这三个部分用于最初的内核态栈帧．
 esp, ss：这两部分用于指明最初的堆栈段选择子与栈指针.
- 加载程序  
 这个过程需要与文件系统配合，将待读入程序从磁盘载入内存缓冲．elf可执行文件中包含了各个程序段的虚拟地址，段区间长度，程序执行入口等信息．其中段虚拟地址偏移与段区间长度信息用于分配虚拟内存空间．程序执行入口用于给eip赋值．
- 创建地址空间  
 这个过程与内存管理系统配合，程序制定想要分配的一个虚拟业，内存管理系统判断虚拟地址的可分配性，满足条件则从空闲物理业中分配．不但用户程序段要有相应的内存映射，每个用户进程都要有映射到内核段的地址空间．
 
####  fork系统调用

fork的作用是创建一个"一模一样"的子进程，具体来说就是赋值PCB中涉及到的每一个域．
这些域包括：  

* PID,优先级，内核栈，锁计数器，消息，运行时间，CR3,页表，物理页，用户栈以及一些标志位等 
* 优先级，标志位等基本数据类型可以直接复制，运行时间清零，pid重新分配
* 指向内核栈上的指针域，包括tf指针和返回地址ebp.

实验中的一个简化：在fork系统调用的过程中，父进程会在中断上下文中再次往PM发送一个请求，然后阻塞在消息队列的信号量上．然而pm只会往父进程发送消息，而子进程不可能获得pm的消息．那么，如果子进程返回到receive的上下问中，将一直在此阻塞．
解决的办法是：将子进程的栈顶设为刚刚从用户空间进入内核空间时候的栈顶，此时，子进程不会被阻塞在receive上，直接返回到用户空间．在进行系统调用的时候，往pm传送刚进入系统时候的trapframe指针作为参数．

#### 让用户进程回归ring3

用户空间应该拥有自己的用户栈，实验中设置为内核映像的下方的一个页，虚拟地址为0xbffff000~0xbfffffff．　

此时内核栈还有用吗，我们是否可以让用户进程只使用用户栈，而不给它分配内核栈．　

考虑一种情况，用户进程在运转的过程中，其间会在用户栈上使用很多空间，系统不能控制用户对用户栈的使用.　　

假设用户栈被占满了，而此时恰好有中断的到来(例如时钟中断）．那么系统会试图保护中断现场，因为我们使用用户栈而非内核栈，中断现场被保存在用户栈的溢出空间．这个触发了栈溢出异常，而为了处理这个异常，还是需要保存中断上下文，这造成了一次double fault，紧接着同样的过程造成了一次triple fault.此时，CPU发现这个致命错误永远不能恢复了，将放弃异常处理，直接重启机器．　　

可以看到，一次用户进程的栈溢出异常使得整个系统重启，这不应该是系统该有的反应．　　

解决方案是：给每个进程分配一个内核栈，在中断现场保护时的入栈操作直接操作内核栈，由于内核栈的使用受控于操作系统，我们能保证拥有足够的内核栈来运行中断处理程序．

#### 内核栈与堆栈段切换

硬件提供了内核栈与堆栈段的切换，具体的切换时机就在每次*触发中断*和执行指令*iret*．

中断信号一来，在idt中寻找相应的段选择子，找到相应的段描述符，段描述符中保存了相应段的代码特权等级，硬件判断根据等级从tss段中获取相应的ss(段描述符)和esp(段指针),完成相应的堆栈切换．j
这完成了从用户栈到内核栈的切换．

每次执行iret，会从栈顶弹出cs,eip,eflags．这个时候硬件会判断当前cs所指的段的特权级以及目标段的等级，如果目标段等级小，机器会将紧接着的内存空间中的内容解释为ss和esp，当然，内核代码必须保存当前内核栈的eip和ss,以便用户进程能够成功切换到内核栈．

这完成了从内核栈到用户栈的切换．

### 内存动态分配

操作系统并没有参与内存的动态分配，只是提供了一个系统调用用户改变数据区的大小：

`void* sbrk(int inc);`　　　　

它接收一个整型参数inc, 用于指示让数据区的大小增长inc个字节, 并返回增长前数据区顶部的位置. 当inc为负数时, 用于释放相应大小的空间. 堆区管理初始化时会调用sbrk(0)返回当前数据段顶部的位置, 这样程序就知道堆区从哪里开始了　　

#### 捕捉用户进程的非法操作

如果用户进程触发了非法操作，如段错误．那么一旦内核检测到这些异常，应该试图判断触发段错误的进程是否是用户进程，此时传入中断处理函数的现场信息trapframe是用户栈的trapframe,我们可以判断这个trapframe的ss段是否是属于用户栈的基地址，就可以判断是否是用户进程触发的错误．
如果是，内核能够调用exit系统调用关闭用户进程，在中断输出*segmentation fault*.

#### 分页保护机制

为了限制用户进程的行为，需要修改相应的页目录项和页表项，使得：
- 用户进程不能访问内核映射区，这是通过设置表项的U/S位实现的
- 用户进程不能修改代码和只读数据，这是通过设置表项中的R/W位实现的，在解析ELF文件的时候，每一个program header会有相应的标志位来指示对应的segment是否可写

#### Copy-On-Write

当父进程创建子进程的时候，可暂时不用复制所有的虚拟空间（深拷贝）内容，而是将相应的物理页设置为共享态．当父子进程其中之一试图写共享物理页时候，为其复制一份拷贝．
因此必须有相应的数据结构来记录一个物理页的状态，当物理页为共享态时候，将其设置为只读．
内核必须能够区分对*只读页*的写操作和对*共享页*的写操作．
我们可以在内核中创建一个表示物理页面的状态的结构，其中包括是否共享页面，页面的引用计数器，这样便可以区分上面两个操作．

当进程退出时候，内核不应该立刻回收相应物理页，而是将引用计数减小．
进程载入的一个trick:
  当进程载入时候，只是填写相应的页目录项，而将页表项上的标志设置为*缺页*,同时对相应物理页设置*未载入*标志位．这样当发生缺页中断时候，内核就会发现是未载入的物理页，从而在相应的文件中寻找目标页更新页表项．